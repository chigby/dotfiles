alias man='LC_ALL=C LANG=C man'
alias f=finger
alias ll='ls -alh'
alias la='ls -a'
alias ls='ls -F --color=auto '

# Directory navigation, e.g.:
# cd by .. or ... or ... or mv file ..../.
alias '..'='cd ..'
alias -g ...='../..'
alias -g ....='../../..'
alias -g .....='../../../..'

alias svnst="svn --ignore-externals status | grep ^[ACDGMR?]"
alias svndi="svn diff|colordiff"

alias portup='sudo port selfupdate && sudo port upgrade outdated'

alias sdf='ssh sdf.lonestar.org -l chigby'
alias sverige='ssh sverige.freeshell.org -l chigby'
alias svalbard='ssh svalbard.freeshell.org -l chigby'
alias otaku='ssh otaku.freeshell.org -l chigby'
alias iceland='ssh iceland.freeshell.org -l chigby'

alias j='jobs'
alias s='sudo -s'
alias xterm='xterm -fa Monaco -fs 11 &'
alias tar='gnutar'
alias df='df -h'
alias du='du -h'

alias ipython='ipython -classic'
alias thes='dict -d moby-thes'

# find all installed packages that depends on a given package.
function rdep () {
    apt-cache rdepends $1|sed '1,2d'|sort|uniq|xargs apt-cache policy |grep "Installed: [0-9]" -B1
}

function tng() {
    subcommand=$1
    revfile=~/Documents/tng/tng_all.tar.bz2
    if [[ $subcommand == 'rev' ]]; then
	file="$2.rev"
	gnutar -xjvOf $revfile $file | less
    elif [[ $subcommand == 'search' ]]; then
	term=$2
	gnutar -tf $revfile | grep $term
    elif [[ $subcommand == 'help' ]]; then
	echo "Available subcommands:"
	echo "tng rev [name] -- Display review with name [name]."
	echo "tng search [name] -- List review names matching [name]."
	echo "tng help -- Display this help."
    else
	echo "Subcommand '$subcommand' not found."
    fi
}

alias vless='vim -u /usr/share/vim/vim71/macros/less.vim'

alias dnsreset='sudo launchctl stop org.macports.dnsmasq && sudo launchctl start org.macports.dnsmasq && sudo dscacheutil -flushcache'

###
# functions
###

# Human readable mtime of file(s).
lmod () {
    if test -n "$1"; then
	td $(( `date '+%s'` - `stat -f '%m' "$1"` )) | sed "s#^#$1    modified #" | sed 's/$/ ago/'
    else
	lines=$(while read line; do echo "$line"; done)
	longest=$(echo $lines | awk '{print length(), $0 | "sort -nr"}' | head | awk '{print $1}' | head -n1)
	for line in $(echo $lines | xargs); do
	    lmod "$line" | awk "{printf \"%-${longest}s    %s\n\", \$1,\$2}" FS='    '
	done
    fi
}

cd() {
    if [  -n "$1" ]; then
	builtin cd "$@" && ls
    else
	builtin cd ~ && ls
    fi
}

decruft () {
    for ext in .pyc \~; do
	rm -f **/*$ext(N)
	done
}

# Colorize tail output for log monitoring.
ctail () {
    tail "$@" | perl -pe 'sub c {%c=("ERROR",31,"INFO",32,"DEBUG",36,"WARNING",33,"CRITICAL",35);"\e[1;".$c{@_[0]}."m".@_[1]}s/.*\b(ERROR|WARNING|CRITICAL|DEBUG|INFO)\b.*/c($1,$&)/ge;'
}

# Strip ANSI formatting from text
function noansi () {
    perl -pe "s/\x1B\[([0-9]{1,2}(;[0-9]{1,2})?)?[m|K]//g"
}

# Convert epoch timestamp to human readable format
function epoch2date() {
    `date --version &> /dev/null` && DATEVER=gnu || DATEVER=bsd
    if test -n "$1"
    then
	if [[ "$DATEVER" = bsd ]]; then
	    date -r "$1"
	else
	    date -d "1970-01-01 $1 sec GMT"
	fi
    else
	while read line
	do
	    if [[ "$DATEVER" = bsd ]]; then
		date -r "$line"
	    else
		date -d "1970-01-01 $line sec GMT"
	    fi
	done
    fi
}

function irssi () {
    if [[ $TERM != xterm-color ]]; then
	TERM=xterm-color
    fi
    /opt/local/bin/irssi
    TERM=xterm
}